args: {
	//Cache backend for blobdescriptor default 'inmemory' you can also use redis
	storageCache: "inmemory" | "redis"

	//Enable metrics endpoint
	enableMetrics: true

	//This is the username allowed to login and push items to the registry. Default is randomly generated and can be obtained from the secret"
	htpasswdUsername: ""

	//Number of registry containers to run.
	scale: 1

	//Provide the complete storage configuration blob in registry config format.
	storageConfig: {}

	//Provide the complete auth configuration blob in registry config format.
	authConfig: {}

	//Provide additional configuration for the registry
	extraRegistryConfig: {}
}

containers: {
	registry: {
		image:  "registry:2.8.1"
		scale:  args.scale
		expose: "5000:5000/http"
		if args.enableMetrics {
			ports: "5001:5001/http"
		}
		files: {
			"/auth/htpasswd":                  "secret://generated-htpasswd/content?onchange=no-action"
			"/etc/docker/registry/config.yml": "secret://registry-config/template?onchange=redeploy"
		}
		probes: ready: "http://localhost:5000"
	}
}

jobs: {
	"htpasswd-create": {
		env: {
			"USER": "secret://registry-user-creds/username"
			"PASS": "secret://registry-user-creds/password"
		}
		entrypoint: "/bin/sh -c"
		image:      "httpd:2"
		// Output of a generated secret needs to be placed in the file /run/secrets/output.
		cmd: ["htpasswd -Bbc /run/secrets/output $USER $PASS"]
	}
}

acorns: {
	if args.storageCache == "redis" {
		redis: {
			build: "../redis"
			ports: {
				"6379:6379/tcp"
			}
		}
	}
}

secrets: {
	"registry-user-creds": {
		type: "basic"
		data: {
			username: "\(args.htpasswdUsername)"
		}
	}
	"generated-htpasswd": {
		type: "generated"
		params: {
			job: "htpasswd-create"
		}
	}
	"registry-config": {
		type: "template"
		data: {template: std.toYAML(localData.registryConfig)}
	}
	"registry-http-secret": type: "token"

	// Provides user a target to bind in secret data
	"user-secret-data": type: "opaque"
}

localData: {
	storageDriver: args.storageConfig
	if len(storageDriver) == 0 {
		storageDriver: filesystem: rootdirectory: "/var/lib/registry"
	}

	authConfig: args.authConfig
	if len(authConfig) == 0 {
		authConfig: htpasswd: {
			realm: "Registry Realm"
			path:  "/auth/htpasswd"
		}
	}

	registryConfig: args.extraRegistryConfig & {
		version: "0.1"
		log: fields: service:           "registry"
		storage: cache: blobdescriptor: args.storageCache
		storage: storageDriver
		auth:    authConfig
		http: {
			addr:   ":5000"
			secret: "${secret://registry-http-secret/token}"
			headers: {
				"X-Content-Type-Options": ["nosniff"]
			}
		}
		health: {
			storagedriver: {
				enabled:   true
				interval:  "10s"
				threshold: 3
			}
		}
	}

	if args.storageCache == "redis" {
		registryConfig: redis: {
			password:     string | *"${secret://redis.redis-auth/token}"
			addr:         "redis:6379"
			db:           0
			dialtimeout:  string | *"10ms"
			readtimeout:  string | *"10ms"
			writetimeout: string | *"10ms"
			pool: {
				maxidle:     int | *16
				maxactive:   int | *64
				idletimeout: string | *"300s"
			}
		}
	}

	if args.enableMetrics {
		registryConfig: metricsConfig: debug: {
			addr: "0.0.0.0:5001"
			prometheus: {
				enabled: true
				path:    "/metrics"
			}
		}
	}
}
